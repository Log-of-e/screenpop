// Filename: screenpop.full.js  
// Timestamp: 2014/01/15 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)  

// Filename: lockfnthrottling.js
// Timestamp: 2013.09.01-22:32:43 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
//
//
// The constructed function is called multiple times with callbacks.
// One callback is processed and then, during a specified period of time, 
// callbacks that are given afterward are ignored.
// 
// Intended for functions bound to events triggered rapidly many times.
// 
// lockFnThrottling = LockFnThrottling.getNew({ ms : 500 });
// lockFnThrottling(function () { console.log('go!') }); // go
// lockFnThrottling(function () { console.log('go!') });

var lockfnthrottling =
  ((typeof module === 'object') ? module : {}).exports = (function () {

  var throttle = {
    ms : 500,
    timer : null,
    lastFn : null,

    throttledFn : function (fn) {
      var that = this;

      if (that.timer) {
        that.lastFn = fn;
      } else {
        that.timer = setTimeout(function () {
          if (that.lastFn) {
            that.lastFn();
            that.lastFn = null;
          }
          clearTimeout(that.timer);
          that.timer = null;
        }, that.ms); 
        fn();
      }
    }
  };

  return {
    getNew : function (spec) {
      var that = Object.create(throttle);
      that.ms = spec.ms || 500;
      that.timer = null;
      that.lastFn = null;
      return function (fn) { that.throttledFn(fn); };
    }
  };

}());
// Filename: lockfnrebounding.js
// Timestamp: 2013.09.01-22:32:26 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
//
// first function is processed until a value is reached...
// during that time, future calls are rebounded until the function returns
// useful for button press or form submission calls

var lockfnrebounding =
  ((typeof module === 'object') ? module : {}).exports = (function () {

  var cache = {
    flag : false,

    go : function (fn) {
      var that = this, 
          flag = that.flag;

      if (flag === false) {
        that.flag = true;
        fn(function () { that.flag = false; });        
      }
    }
  };

  return {
    getNew : function () {
      var that = Object.create(cache);
      that.flag = false;
      return function (fn) { that.go(fn); };
    }
  };

}());
// Filename: lockfnqueuing.js
// Timestamp: 2013.09.01-22:32:08 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
//
// the returned function stores mulitple callbacks and processes them one after
// another -waiting for the first to complete before calling the next, useful
// for holding off execution of function bodies that add numerous calls to the 
// stack.
// 
// lockFnQueueing = LockFnQueuing.getNew();
// lockFnQueueing(callback, function (exitFn) {
//   x = 5;
//   exitFn(null, x);
// });

var lockfnqueuing =
  ((typeof module === 'object') ? module : {}).exports = (function () {

  var cache = {
    isActive : false,
    fnArr : [],
    getValArr : [],

    callLimit : function () {
      var that = this, 
          onValArr = that.fnArr, 
          getValArr = that.getValArr;

      (function nextCall (x, getVal, onVal) {
        getVal = getValArr.shift();
        onVal = onValArr.shift();
        getVal(function (a, b, c) {
          if (onVal) onVal(a, b, c);
          if (getValArr.length) {
            nextCall(getValArr.length);            
          } else {
            that.isActive = false;
          }
        });
      }(getValArr.length));
    },

    queueAdd : function (onValFn, getValFn) {
      var that = this;
      that.fnArr.push(onValFn);
      that.getValArr.push(getValFn);
      if (that.isActive === false) {
        that.isActive = true;
        that.callLimit();
      }
    }
  };

  return {
    getNew : function () {
      var that = Object.create(cache);
      that.isActive = false;
      that.fnArr = [];
      that.getValArr = [];
      return function (onValFn, getValFn) { 
        that.queueAdd(onValFn, getValFn); 
      };
    }
  };

}());
// Filename: lockfncaching.js
// Timestamp: 2013.09.01-22:31:53 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
//
// gets a value with getValFn, then calls onValFn(err, res)
// multiple requests made to the returned function are served
// a value that is once-only generated by onValFun
// 
// --------------------------------------------------------
// var fncaching = LockFnCaching.getNew();
// var onValFn = function (err, val) {
//   console.log(null, val);
// };
// fncaching(onValFn, function getValFn (exitFn) {
//   exitFn(null, 3);
// });
// 
// "null, 3"
//


var lockfncaching =
  ((typeof module === 'object') ? module : {}).exports = (function () {

  var cache = {
    val : undefined,
    isActive : false,
    funcArr : [],

    callFuncArr : function (err, blocks) {
      var that = this, funcArr = that.funcArr;
      that.isActive = false;
      while (funcArr.length) funcArr.pop()(err, blocks);
    },

    // persists the returned value with this object
    cacheVal : function (onValFunc, getValFunc) {
      var that = this, val = that.val;

      that.funcArr.push(onValFunc);
      if (that.isActive === false) {
        that.isActive = val === undefined;
        if (typeof val === 'undefined') {
          getValFunc(function (err, newVal) {
            if (err) return that.callFuncArr(err, newVal);
            that.callFuncArr(err, (that.val = newVal));
          });
        } else {
          that.callFuncArr(null, val);
        }
      }
    }
  };

  return {
    getNew : function () {
      var that = Object.create(cache);
      that.isActive = false;
      that.funcArr = [];
      that.val = undefined;
      return function (onValFunc, getValFunc) { 
        that.cacheVal(onValFunc, getValFunc); 
      };
    },

    getNamespaceCache : (function () {
      var namespacesObj = {};
      return function (namespace) {
        return namespacesObj[namespace] ||
          (namespacesObj[namespace] = this.getNew());
      };
    }()),

    getNamespaceNew : function () {
      var that = this, caching;
      return function (namespace, onValFunc, getValFunc) { 
        caching = that.getNamespaceCache(namespace);
        caching(onValFunc, getValFunc); 
      };
    }
  };

}());
// Filename: lockfn.js
// Timestamp: 2013.09.05-19:26:00 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
// Requires: lockfncaching.js, lockfnqueuing.js, 
// lockfnrebounding.js, lockfnthrottling.js






var lockfn =
  ((typeof module === 'object') ? module : {}).exports = (function () {

  return {
    Queuing : lockfnqueuing,
    Caching : lockfncaching,
    Rebounding : lockfnrebounding,
    Throttling : lockfnthrottling
  };

}());// Filename: lsn.js
// Timestamp: 2013.12.18-10:52:52 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)

var lsn = (function (de, deffn, o, p) {

  de = document.documentElement;
  deffn = function () {};

  function isMethod (o) {
    return /^(?:function|object|unknown)$/.test(typeof o) ? true : false;
  }

  o = {
    add : (function (fn) {
      if (isMethod(de.addEventListener)) {
        fn = function (el, e, fn) {
          el.addEventListener(e, fn, false);
        };
      } else if (isMethod(de.addatchEvent)) {
        fn = function (el, e, fn) {
          el.attachEvent('on'+e, function (e) {
            fn(e || window.event);
          });
        };
      }
      return fn || deffn;
    }()),

    rm : (function (fn) {
      if (isMethod(de.removeEventListener)) {      
        fn = function (el, e, fn) {
          el.removeEventListener(e, fn, false);
        };
      } else if (isMethod(de.detachEvent)) {      
        fn = function (el, e, fn) {
          el.detachEvent('on'+e, fn);
        };
      }
      return fn || deffn;
    }())
  };

  p = o.add;
  p.rm = o.rm;

  return p;
}());


// Filename: domwh.js  
// Timestamp: 2013.12.24-17:03:48 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)  

var domwh = (function (p, d, doc) {

  doc = document;

  p = function(elem) {
    var d, dims = [elem.offsetWidth, elem.offsetHeight];

    if (!dims[0]) {
      d = elem.style;      
      if (d.display === 'none') {
        d.display = 'block';
        dims = [elem.offsetWidth, elem.offsetHeight];
        d.display = 'none';
      } else if (d.display === '') {
        d.display = 'block';
        dims = [elem.offsetWidth, elem.offsetHeight];
        d.display = '';
      }
    }
    return dims;
  };

  p.window = function () {
    if (window && window.innerHeight) {
      return [window.innerWidth, window.innerHeight];
    } else if ((d = doc.documentElement)) {
      d = d.clientWidth ? d : doc.documentBody;
      return [d.clientWidth, d.clientHeight];
    } else {
      return null;
    }
  };

  return p;

}());
// Filename: elemst.js  
// Timestamp: 2013.12.16-00:25:06 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)  
//
// methods for handling "state" of an element through className:
//
// elemstate.up()
// elemstate.is()
// elemstate.rm()

var elemst = {

  // elemstate.up(elem, 'select-active');
  // - ensures `st-select-active` is defined on elem.className
  // - if `st-select-active` is defined on elem.className, elem is not modified
  // - if `st-select-\w*` is defined on elem.className, it is replaced.
  // 
  // all states are prefixed with `st-`
  // ex, 
  //  elemstate.up(elem, 'select-active'); // st-select-active
  //  elemstate.up(elem, 'active'); // st-active
  //
  // why? easier to identify and replace classNames associated with this script
  //
  // if a hyphen is given the word behind the first hyphen
  // is recognized as an *id*. word(s) after hyphen are the
  // *state*. if no hyphen, value is assumed to be *state*.
  //
  // Use of *id* allows one to store multiple states on a className, associating 
  // each with a different *id*, for example:
  //  `st-isselected-true st-isopen-true st-iscomplete-false`
  //
  // *id* is not required -this OK:
  //  `st-active`
  //
  up : function (elem, stateidStr) {
    var className, 
        newclass = 'st-' + stateidStr,
        stateid = (stateidStr || '').match(/(\w*(?:-)|\b)(\w*)/) || [],
        state = stateid[2],
        id = stateid[1] || '';

    if (elem && state) {
      className = elem.className;
      if (!className.match(newclass)) {
        stateid = new RegExp('st-' + '\(' + id + '\\w*\)');
        if (className.match(stateid)) {
          elem.className = className.replace(stateid, newclass);
        } else {
          elem.className = className + ' ' + newclass;
        }
      }
    }
  },

  // elemstate.rm(elem, 'select');
  // - removes entire word class with substring at index 0 matching stateidstr
  //
  // console.log(elem.className); // bttn st-select-active st-active
  // elemstate.rm(elem, 'select');
  // console.log(elem.className); // bttn st-active
  // elemstate.rm(elem, 'active');
  // console.log(elem.className); // bttn
  //
  rm : function (elem, stateidStr) {
    var className, 
        stateid = new RegExp('[\b ]st-' + stateidStr + '\(-\\w*\)?');

    if (elem) {
      className = elem.className;
      if (className.match(stateid)) {
        elem.className = className.replace(stateid, '');
      }
    }
  },

  is : function (elem, stateidStr) {
    return (elem && elem.className.match('st-' + stateidStr)) ? true : false;
  }
};
// Filename: screenpop.js
// Timestamp: 2014.01.15-22:19:35 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
// Requires: elemst.js, domwh.js, lsn.js, lockfn.js
//
//
// +-------------------------------------------------+
// | sp-layers                                       |
// |   +-----------------------------------------+   |
// |   | sp-layers-layer                         |   |
// |   |   +---------------------------------+   |   |
// |   |   | sp-layers-layer-screen          |   |   |
// |   |   +---------------------------------+   |   |
// |   |   +---------------------------------+   |   |
// |   |   | sp-layers-layer-content         |   |   |
// |   |   +---------------------------------+   |   |
// |   |                                         |   |
// |   +-----------------------------------------+   |
// |                                                 |
// +-------------------------------------------------+






var screenpop = (function (proto, constructor, deffn) {

  deffn = function (fn) { 
    if (typeof fn === 'function') fn(null, ''); 
  };
  
  proto = {
    count : 0,
    uid : 0,
    hintSize : 20, // number of pixels used to display hint area

    // modules you may want redefined
    throttlefn : lockfn.Throttling.getNew({ ms : 500 }),
    elemst : elemst,
    domwh : domwh,
    lsn : lsn,

    onShutHook : deffn,
    onOpenHook : deffn,
    onRenderHook : deffn,

    onShut : function (fn) {
      this.onShutHook = fn;
      return this;
    },

    onOpen : function (fn) {
      this.onOpenHook = fn;
      return this;
    },

    onRender : function (fn) { 
      this.onRenderHook = fn;
      return this;
    },

    createDiv : function (c, uid) {
      var elem = document.createElement('div');

      if (typeof c === 'string') {
        elem.className = c;
        elem.id = (uid || '') + c;
      }

      return elem;
    },

    connect : function () {
      var that = this;

      that.lsn(document, 'keydown', function (e) {
        if (e && e.keyCode === 27) {
          constructor.shut();
        }
      });

      that.lsn(window, 'resize', function (e) {
        that.throttlefn(function () {
          constructor.center();
        });
      });

      that.lsn(window, 'scroll', function (e) {
        that.throttlefn(function () {
          constructor.centerVert();
        });
      });
    },

    getLoadElemStr : function () {
      return '';
    },

    // was getLayerParent
    getLayersElem : function () {
      var that = this;
      return document.getElementById('sp-layers') || 
        (function (e, d) {
          e = that.createDiv('sp-layers');
          that.container.appendChild(e);
          that.connect();
          return e;
        }());
    },

    createLayerElem : function () {
      var that = this,
          uid = that.uid,
          layerElem = that.createDiv('sp-layers-layer', uid),
          screenElem = that.createDiv('sp-layers-layer-screen', uid),
          contentElem = that.createDiv('sp-layers-layer-content', uid),
          loadElem = that.createDiv('sp-layers-layer-load', uid);          

      loadElem.innerHTML = that.getLoadElemStr();

      layerElem.appendChild(screenElem);
      layerElem.appendChild(loadElem);
      layerElem.appendChild(contentElem);

      layerElem.onclick = function () {
        that.shut();
      };

      return layerElem;
    },

    getLayerElem : function () {
      return document.getElementById(this.uid + 'sp-layers-layer') ||
        this.createLayerElem();
    },
    getContentElem : function () {
      return document.getElementById(this.uid + 'sp-layers-layer-content');
    },
    getLoadElem : function () {
      return document.getElementById(this.uid + 'sp-layers-layer-load');
    },

    getScroll : function () {
      return window.pageYOffset || document.body.scrollTop;
    },
    
    getContentT : function () {
      var contentElem = this.getContentElem(),
          top;

      if (contentElem) {
        top = contentElem.style.margin.match(/^\d*/);
        if (top) {
          top = parseFloat(top[0]);
          top = isNaN(top) ? null : top;
        }
      }

      return top;
    },

    center : function () {
      var that = this,
          contentElem = that.getContentElem(),
          contentWH, windowWH,
          posT, posL;

      if (contentElem) {
        contentWH = that.domwh(contentElem);
        windowWH = that.domwh.window();

        posT = (windowWH[1] - contentWH[1]) / 2;
        posL = (windowWH[0] - contentWH[0]) / 2;

        // restrict top from outside of window
        if (posT < 0) posT = 0;

        contentElem.style.margin = ':tpx :rlpx 0'
          .replace(/:t/, posT + that.getScroll())
          .replace(/:rl/gi, posL);
      }
    },

    centerVert : function () {
      var that = this,
          contentElem = that.getContentElem(),
          contentH, windowH,
          posT, posL, scroll, top, topold;

      if (contentElem) {
        contentH = that.domwh(contentElem)[1];
        windowH = that.domwh.window()[1];
        topold = that.getContentT();
        scroll = that.getScroll();
        posT = (windowH - contentH) / 2;

        if (topold + contentH - that.hintSize <= scroll) {
          // if bottom 'hint' area is not fully visible...
          top = scroll - contentH + that.hintSize;
        } else if (topold >= scroll && posT + scroll < topold) {
          // if top is below top of viewable area &&
          // if top is below the position it would own if 'centered'...
          // if top is not above visible area when centered
          top = (posT > 0) ? posT + scroll : scroll;
        }

        if (typeof top === 'number') {
          contentElem.style.marginTop = ':tpx'.replace(/:t/, top);
        }
      }
    },


    replaceContent : function (o) {
      var contentElem = this.getContentElem();

      if (contentElem) {
        if (typeof o === 'string') {
          contentElem.innerHTML = o;
        } else if (typeof o === 'object' && o && 'tagName' in o) {
          contentElem.appendChild(o);
        }
      }
    },

    pop : function () {
      var that = this,
          layerelem,
          cb = function (e,r) { if (typeof fn === 'function') fn(e,r); };
      
      constructor.shut();
      constructor.screenobjLast = this;

      layerelem = that.getLayerElem();
      that.elemst.up(layerelem, 'screen-load');
      that.getLayersElem().appendChild(layerelem);

      that.onRenderHook(that, function (err, res) {
        if (err) return cb(err);

        that.replaceContent(res);
        that.center();

        that.open();
      });
    },

    open : function () {
      var that = this;

      that.center();
      that.elemst.up(that.getLayerElem(), 'screen-show');
      that.onOpenHook(that);
    },

    load : function () {
      var that = this;

      that.center();
      that.elemst.up(that.getLayerElem(), 'screen-load');
    },

    shut : function () {
      var that = this;

      that.elemst.up(that.getLayerElem(), 'screen-hide');
      that.onShutHook(that);
    },

    rm : function () {
      var layerElem = this.getLayerElem();

      if (layerElem) {
        layerElem.parentNode.removeChild(layerElem);
      }
    },

    clear : function () {
      this.replaceContent('');
    }
  };

  constructor = function (opts) {
    var that = Object.create(proto);

    that.uid = (opts && opts.uid) ? opts.uid : ++proto.count;    
    that.onShutHook = deffn;
    that.onOpenHook = deffn;
    that.onRenderHook = deffn;
    that.container = document.body;

    if (opts) {
      if (typeof opts.hintSize === 'number') {
        that.hintSize = opts.hintSize;
      }

      if (typeof opts.loadElemStr === 'string') {
        that.getLoadElemStr = function () {
          return opts.loadElemStr;
        };
      }
    }

    return that;
  };

  constructor.proto = proto;
  constructor.screenobjLast = null;
  constructor.shut = function () {
    var sol = this.screenobjLast;
    if (sol) sol.shut();
  };

  constructor.rm = function () {
    var sol = this.screenobjLast;
    if (sol) sol.rm();
  };

  constructor.center = function () {
    var sol = this.screenobjLast;
    if (sol) sol.center();
  };

  constructor.centerVert = function () {
    var sol = this.screenobjLast;
    if (sol) sol.centerVert();
  };

  return constructor;

}());

// Filename: screenpop.full.js  
// Timestamp: 2014.01.15-20:38:27 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)  
// Requires: screenpop.js
//
// placeholder file for directing scroungejs build
